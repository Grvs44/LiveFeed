import azure.functions as func
from azure.cosmos import CosmosClient
import math
import os
import logging
import datetime
import json
import jwt
from shared_code import messages, streaming
import requests
from azure.messaging.webpubsubservice import (
    WebPubSubServiceClient
)
from jwt import PyJWKClient
from msal import ConfidentialClientApplication
from datetime import datetime, timezone

app = func.FunctionApp()

client = CosmosClient("https://livefeed-storage.documents.azure.com:443/", "RMcJvdRXCSCk60vX8ga7uAdnfl2yKW1nGBDf0EKcHc8NtdwKs72NAq2mDtUk8hW6NWwN3RnXMUFxACDbWLE70A==")
database = client.get_database_client('Recipes')
user_database = client.get_database_client('Users')
recipe_container = database.get_container_client('UploadedRecipes')
stream_container = database.get_container_client('Streams')
prefs_container = user_database.get_container_client('Preferences')

NOTIFY_HUB_NAME = 'livefeed-notify'
CHAT_HUB_NAME = 'livefeed'
PUBSUB_CONNECTION_STRING = os.environ.get('WebPubSubConnectionString')
CHAT_PUBSUB_SERVICE = WebPubSubServiceClient.from_connection_string(PUBSUB_CONNECTION_STRING, hub=CHAT_HUB_NAME)

CLIENT_ID = os.environ.get("AzureB2CAppID")
TENANT_ID = os.environ.get("AzureB2CTenantID")
TENANT_NAME = os.environ.get("AzureB2CTenantName")
POLICY_NAME = os.environ.get("AzureB2CPolicyName")
SECRET = os.environ.get("AzureB2CAppSecret")

ISSUER = f"https://{TENANT_NAME}.b2clogin.com/{TENANT_ID}/v2.0/"
JWKS_URL = f"https://{TENANT_NAME}.b2clogin.com/{TENANT_NAME}.onmicrosoft.com/discovery/v2.0/keys?p={POLICY_NAME}"

msal_client = ConfidentialClientApplication(
    client_id=CLIENT_ID,
    client_credential=SECRET,
    authority=f"https://login.microsoftonline.com/{TENANT_ID}"
)
current_date = datetime.now(timezone.utc).isoformat(timespec='minutes')

def get_web_access_token():
    result = msal_client.acquire_token_for_client(scopes=["https://graph.microsoft.com/.default"])
    if "access_token" in result:
        return result["access_token"]
    else:
        raise Exception("Access token not acquired")

def get_display_name(object_id):
    token = get_web_access_token()
    headers = {"Authorization": f"Bearer {token}"}
    url = f"https://graph.microsoft.com/v1.0/users/{object_id}"

    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        user_data = response.json()
        return user_data.get("displayName")
    else:
        raise Exception(f"Couldn't get user: {response.status_code}, {response.text}")
    
def validate_token(req):
    """
    Validates a token and returns its associated claims.

    Args:
        token (string): The access token provided by the client app.
    Returns:
        claim_info (dict): A dictionary containing 'claims' if the provided token is valid,
        and an 'error' containing a HttpResponse if the token is invalid.
    """
    auth_header = req.headers.get("Authorization")
    claim_info = {'claims': None, 'error': None}

    if auth_header is None or not auth_header.startswith("Bearer "):
        claim_info['error'] = func.HttpResponse("No token provided", status_code=401)
        return claim_info
    token = auth_header.split(" ")[1]

    try:
        # Get JWKS keys
        jwks_client = PyJWKClient(JWKS_URL)
        signing_key = jwks_client.get_signing_key_from_jwt(token)

        # Decode and validate the token
        payload = jwt.decode(
            token,
            signing_key.key,
            algorithms=["RS256"],
            audience=CLIENT_ID,
            issuer=ISSUER,
        )

        claim_info['claims'] = payload
        logging.info(f"Identified sender as {payload.get('name')} ({payload.get('sub')})")
    except jwt.ExpiredSignatureError:
        claim_info['error'] = func.HttpResponse("Token has expired", status_code=401)
    except jwt.InvalidTokenError as e:
        claim_info['error'] = func.HttpResponse(f"Invalid token: {e}", status_code=401)
    
    return claim_info

############################
#---- Stream Functions ----#
############################

@app.route(route="streams", auth_level=func.AuthLevel.ANONYMOUS, methods=[func.HttpMethod.GET])
def get_streams_info(req: func.HttpRequest) -> func.HttpResponse:
    try:
        stream_query = """
        SELECT c.id, c.stream_url, c.live_status
        FROM Streams c
        """
        stream_items = list(stream_container.query_items(
            query=stream_query,
            enable_cross_partition_query=True
        ))

        stream_ids = [s["id"] for s in stream_items]
        
        id_list = "', '".join(stream_ids)
        recipe_query = f"""
        SELECT c.id, c.image, c.title, c.tags
        FROM UploadedRecipes c
        WHERE c.id IN ('{id_list}')
        """
        recipe_items = list(recipe_container.query_items(
            query=recipe_query,
            enable_cross_partition_query=True
        ))

        recipe_map = {r["id"]: r for r in recipe_items}

        # Merge Streams & Recipes
        combined_list = []
        for s in stream_items:
            rid = s["id"]
            recipe = recipe_map.get(rid, {})
            combined_list.append({
                "id": rid,
                "stream_url": s.get("stream_url", ""),
                "live_status": s.get("live_status", 3), # 0: Upcoming, 1: Live, 2: On-demand
                "image": recipe.get("image", ""),
                "title": recipe.get("title", ""),
                "tags": recipe.get("tags", [])
            })

        response_body = json.dumps(combined_list)
        return func.HttpResponse(response_body, status_code=200)

    except Exception as e:
        logging.error(f"Error retrieving streams: {str(e)}")
        return func.HttpResponse("Error retrieving streams data", status_code=500)

def get_stream_from_db(recipe_id, user_id):
    stream_data = stream_container.read_item(recipe_id, partition_key=recipe_id)
    streamer_id = stream_data.get('user_id')
    recipe_data = recipe_container.read_item(recipe_id, partition_key=streamer_id)
    step_timings = stream_data.get('step_timings')

    timed_steps = [{"id": step.get('id'), "text": step.get('text'), "time": step_timings.get(str(step.get('id')))} for step in recipe_data.get('steps')]

    stream_dict = {
        "name": recipe_data.get('title'),
        "stream": stream_data.get("stream_url"),
        "streamer": get_display_name(streamer_id),
        "group": recipe_id,
        "recipe": timed_steps,
        "shopping": recipe_data.get('shopping')
    }

    stream_dict['input'] = stream_data.get('input_url')

    live_status = stream_data.get('live_status')
    if live_status is not None:
        stream_dict['liveStatus'] = live_status
    # for testing:
    else:
        stream_dict['liveStatus'] = 0

    return stream_dict

@app.route(route='stream/{recipeId}', auth_level=func.AuthLevel.ANONYMOUS, methods=[func.HttpMethod.GET])
def get_stream_info(req: func.HttpRequest) -> func.HttpResponse:
    claim_info = validate_token(req)
    user_id = None
    if (claim_info.get('claims') != None):
        user_id = claim_info.get('claims').get('sub')

    recipe_id = req.route_params.get('recipeId')
    stream_dict = get_stream_from_db(recipe_id, user_id)

    return func.HttpResponse(json.dumps(stream_dict), mimetype='application/json', status_code=200)

@app.route(route='vod/{recipeId}', auth_level=func.AuthLevel.ANONYMOUS, methods=[func.HttpMethod.GET])
def get_vod_info(req: func.HttpRequest) -> func.HttpResponse:
    claim_info = validate_token(req)
    user_id = None
    if (claim_info.get('claims') != None):
        user_id = claim_info.get('claims').get('sub')

    recipe_id = req.route_params.get('recipeId')
    stream_dict = get_stream_from_db(recipe_id, user_id)

    return func.HttpResponse(json.dumps(stream_dict), mimetype='application/json', status_code=200)